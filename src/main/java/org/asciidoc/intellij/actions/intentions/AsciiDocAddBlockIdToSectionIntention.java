package org.asciidoc.intellij.actions.intentions;

import com.intellij.codeInsight.intention.preview.IntentionPreviewInfo;
import com.intellij.openapi.editor.Editor;
import com.intellij.openapi.fileEditor.FileEditor;
import com.intellij.openapi.project.Project;
import com.intellij.psi.PsiElement;
import com.intellij.psi.PsiFile;
import com.intellij.psi.PsiWhiteSpace;
import com.intellij.psi.impl.source.PostprocessReformattingAspect;
import org.asciidoc.intellij.file.AsciiDocFileType;
import org.asciidoc.intellij.lexer.AsciiDocTokenTypes;
import org.asciidoc.intellij.psi.AsciiDocSection;
import org.asciidoc.intellij.psi.AsciiDocUtil;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;

public class AsciiDocAddBlockIdToSectionIntention extends Intention {

  @Override
  public @NotNull IntentionPreviewInfo generatePreview(@NotNull Project project, @NotNull Editor editor, @NotNull PsiFile file) {
    if (editor instanceof FileEditor) {
      if (file.getVirtualFile().equals(((FileEditor) editor).getFile())) {
        return IntentionPreviewInfo.EMPTY;
      }
    }
    return super.generatePreview(project, editor, file);
  }

  @Override
  public boolean isAvailable(@NotNull Project project, Editor editor, PsiFile file) {
    if (editor == null || file == null) {
      return false;
    }
    if (AsciiDocFileType.INSTANCE != file.getFileType()) {
      return false;
    }
    if (editor.getSelectionModel().getSelectedText() != null) {
      return true;
    }
    AsciiDocSection section = getSectionWithoutBlockIdAtCursor(file, editor);
    return section != null;
  }

  @Nullable
  public static AsciiDocSection getSectionWithoutBlockIdAtCursor(PsiFile file, Editor editor) {
    PsiElement statementAtCaret = file.findElementAt(editor.getSelectionModel().getSelectionStart());
    if (statementAtCaret == null &&
      editor.getSelectionModel().getSelectionStart() == editor.getDocument().getTextLength() &&
      editor.getDocument().getTextLength() > 0) {
      // cursor is at the very end of the file, and there is document content, move one character
      statementAtCaret = file.findElementAt(editor.getSelectionModel().getSelectionStart() - 1);
    }
    while (statementAtCaret instanceof PsiWhiteSpace) {
      if (statementAtCaret.getTextOffset() == 0) {
        return null;
      }
      statementAtCaret = file.findElementAt(statementAtCaret.getTextOffset() - 1);
    }
    if (statementAtCaret == null) {
      return null;
    }
    if (statementAtCaret.getNode() != null && statementAtCaret.getNode().getElementType() == AsciiDocTokenTypes.HEADING_TOKEN) {
      statementAtCaret = statementAtCaret.getParent();
    }
    while (!(statementAtCaret instanceof AsciiDocSection)) {
      statementAtCaret = statementAtCaret.getParent();
      if (statementAtCaret == null) {
        return null;
      }
    }
    AsciiDocSection section = (AsciiDocSection) statementAtCaret;
    if (section.getBlockId() != null) {
      return null;
    }
    return section;
  }

  @Override
  public void invoke(@NotNull Project project, Editor editor, PsiFile file) {
    AsciiDocSection section = getSectionWithoutBlockIdAtCursor(file, editor);
    if (section != null) {
      String id = section.getAutogeneratedId();
      PostprocessReformattingAspect.getInstance(project).disablePostprocessFormattingInside(() -> {
        PsiElement firstChild = section.getFirstChild();
        for (PsiElement child : createBlockId(project,
          "[#" + id + "]\n").getChildren()) {
          section.addBefore(child,
            firstChild);
        }
      });
    }
  }

  @NotNull
  private static PsiElement createBlockId(@NotNull Project project, @NotNull String text) {
    return AsciiDocUtil.createFileFromText(project, text);
  }

  @Override
  public boolean startInWriteAction() {
    return true;
  }
}
